<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Card Game - Multiplayer</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
        }

        #game-container {
            width: 95vw;
            max-width: 1400px;
            height: 95vh;
            position: relative;
        }

        /* Lobby screen */
        #lobby-screen {
            background: rgba(0, 0, 0, 0.8);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            min-width: 400px;
        }

        #lobby-screen h1 {
            font-size: 48px;
            margin-bottom: 30px;
            color: #ffd700;
        }

        #lobby-screen input {
            width: 100%;
            padding: 10px;
            font-size: 18px;
            margin-bottom: 20px;
            border-radius: 5px;
            border: none;
        }

        #lobby-screen button {
            padding: 15px 40px;
            font-size: 20px;
            background: #ffd700;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
            margin: 10px;
        }

        #lobby-screen button:hover {
            transform: scale(1.05);
        }

        #room-code-display {
            font-size: 32px;
            color: #ffd700;
            font-weight: bold;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 215, 0, 0.2);
            border-radius: 10px;
        }

        #players-list {
            text-align: left;
            margin: 20px 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .player-item {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        .player-item.ready {
            background: rgba(76, 175, 80, 0.3);
        }

        /* Include all styles from original card_game.html */
        #game-table {
            display: none;
            width: 100%;
            height: 100%;
            position: relative;
        }

        #center-area {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: flex;
            gap: 40px;
            align-items: center;
            z-index: 50;
        }

        #deck-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #deck-visual {
            position: relative;
            width: 70px;
            height: 100px;
            margin-bottom: 10px;
        }

        #deck-visual .card {
            position: absolute;
        }

        #pile-container {
            min-width: 150px;
            min-height: 200px;
            background: rgba(0, 0, 0, 0.3);
            border: 3px dashed rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            padding: 20px;
            position: relative;
        }

        #pile {
            position: relative;
            min-height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #pile .card {
            position: absolute;
        }

        #pile .card:last-child {
            z-index: 100;
        }

        #pile-info, #deck-info {
            margin-top: 10px;
            font-size: 14px;
            opacity: 0.8;
        }

        .card {
            width: 70px;
            height: 100px;
            background: white;
            border: 2px solid #333;
            border-radius: 8px;
            display: inline-flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            user-select: none;
        }

        .card:hover {
            transform: translateY(-10px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }

        .card.selected {
            transform: translateY(-20px);
            box-shadow: 0 10px 30px rgba(255, 215, 0, 0.8);
            border-color: #ffd700;
        }

        .card.red {
            color: #d32f2f;
        }

        .card.black {
            color: #333;
        }

        .card.face-down {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: transparent;
        }

        .card.face-down::after {
            content: '🂠';
            position: absolute;
            font-size: 40px;
            color: white;
        }

        .player-area {
            position: absolute;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            min-width: 250px;
        }

        .player-area.current-turn {
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .player-area.under-attack {
            border-color: #ff4444;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.8);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 68, 68, 0.8); }
            50% { box-shadow: 0 0 30px rgba(255, 68, 68, 1); }
        }

        .player-area.targetable {
            border-color: #ff6b6b;
            cursor: pointer;
        }

        .player-area.targetable:hover {
            border-color: #ff0000;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
        }

        .player-name {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #ffd700;
        }

        .player-cards {
            display: flex;
            gap: 5px;
            flex-wrap: nowrap;
            margin-top: 10px;
            overflow-x: auto;
            max-width: 100%;
            padding-bottom: 5px;
        }

        .player-cards::-webkit-scrollbar {
            height: 6px;
        }

        .player-cards::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .player-cards::-webkit-scrollbar-thumb {
            background: rgba(255, 215, 0, 0.5);
            border-radius: 3px;
        }

        .card-section {
            margin-bottom: 10px;
        }

        .card-section-label {
            font-size: 12px;
            opacity: 0.7;
            margin-bottom: 5px;
        }

        .card-stack {
            display: inline-block;
            position: relative;
            margin-right: 15px;
        }

        .card-stack .card.face-down {
            position: relative;
            z-index: 1;
        }

        .card-stack .card.face-up {
            position: absolute;
            top: -30px;
            left: 0;
            z-index: 2;
        }

        .card-stack-container {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            min-height: 130px;
        }

        #player-0 { bottom: 10px; left: 50%; transform: translateX(-50%); max-width: 500px; }
        #player-1 { top: 20px; left: 20px; max-width: 280px; }
        #player-2 { top: 20px; right: 20px; max-width: 280px; }
        #player-3 { bottom: 20px; left: 20px; max-width: 280px; }
        #player-4 { bottom: 20px; right: 20px; max-width: 280px; }

        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        #play-btn {
            background: #4caf50;
            color: white;
        }

        #play-btn:hover:not(:disabled) {
            background: #45a049;
        }

        #play-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        #pickup-btn {
            background: #f44336;
            color: white;
        }

        #pickup-btn:hover:not(:disabled) {
            background: #da190b;
        }

        #messages {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 18px;
            max-width: 600px;
            text-align: center;
            z-index: 100;
        }

        .message-highlight {
            color: #ffd700;
            font-weight: bold;
        }

        #setup-faceup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 1000;
            display: none;
        }

        #setup-faceup h2 {
            margin-bottom: 20px;
            color: #ffd700;
        }

        #setup-faceup .player-cards {
            justify-content: center;
            margin: 20px 0;
        }

        #setup-faceup button {
            background: #ffd700;
            color: #333;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Lobby Screen -->
        <div id="lobby-screen">
            <h1>🃏 Card Game</h1>

            <div id="initial-choice">
                <input type="text" id="player-name" placeholder="Enter your name" maxlength="20">
                <br>
                <button onclick="createRoom()">Create New Game</button>
                <button onclick="showJoinRoom()">Join Game</button>
            </div>

            <div id="join-room-input" style="display: none;">
                <input type="text" id="room-code-input" placeholder="Enter room code" maxlength="6" style="text-transform: uppercase;">
                <br>
                <button onclick="joinRoom()">Join</button>
                <button onclick="showInitialChoice()">Back</button>
            </div>

            <div id="waiting-room" style="display: none;">
                <div id="room-code-display"></div>
                <h3>Players in Lobby:</h3>
                <div id="players-list"></div>
                <button id="ready-btn" onclick="markReady()">Ready!</button>
                <p style="margin-top: 20px; font-size: 14px; opacity: 0.7;">Waiting for all players to be ready...</p>
            </div>
        </div>

        <!-- Face-up card selection -->
        <div id="setup-faceup">
            <h2 id="faceup-player-name">Choose Face-Up Cards</h2>
            <p>Select 3 cards to place face-up (click to select/deselect)</p>
            <div class="player-cards" id="faceup-cards"></div>
            <button onclick="confirmFaceUp()">Confirm Selection</button>
        </div>

        <!-- Game Table -->
        <div id="game-table">
            <div id="messages"></div>

            <div id="center-area">
                <div id="deck-container">
                    <div id="deck-visual"></div>
                    <div id="deck-info">Deck: 0 cards</div>
                </div>

                <div id="pile-container">
                    <div id="pile"></div>
                    <div id="pile-info">Pile: 0 cards</div>
                </div>
            </div>

            <div id="controls">
                <button id="play-btn" onclick="playCards()" disabled>Play Selected Cards</button>
                <button id="pickup-btn" onclick="pickupPile()" disabled>Pick Up Pile</button>
            </div>
        </div>
    </div>

    <script>
        // Socket.io connection
        const socket = io();

        // Game constants
        const Rank = {
            TWO: 2, THREE: 3, FOUR: 4, FIVE: 5, SIX: 6, SEVEN: 7, EIGHT: 8,
            NINE: 9, TEN: 10, JACK: 11, QUEEN: 12, KING: 13, ACE: 14
        };

        const RANK_NAMES = {
            2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8',
            9: '9', 10: '10', 11: 'J', 12: 'Q', 13: 'K', 14: 'A'
        };

        const SUITS = ['♠', '♥', '♦', '♣'];

        // Multiplayer state
        let myPlayerId = null;
        let myPlayerIndex = null;
        let roomCode = null;
        let roomPlayers = [];

        // Game state (will be synced across all players)
        let game = {
            players: [],
            deck: [],
            pile: [],
            currentPlayerIdx: 0,
            skipsRemaining: 0,
            aceAttackTarget: null,
            selectedCards: [],
            setupPhase: 'init',
            setupPlayerIdx: 0,
            waitingForTarget: false
        };

        // Card class
        class Card {
            constructor(rank, suit) {
                this.rank = rank;
                this.suit = suit;
            }

            toString() {
                return RANK_NAMES[this.rank] + this.suit;
            }

            isRed() {
                return this.suit === '♥' || this.suit === '♦';
            }
        }

        // Player class
        class Player {
            constructor(name, id) {
                this.name = name;
                this.id = id;
                this.hand = [];
                this.faceUp = [];
                this.faceDown = [];
            }

            hasCards() {
                return this.hand.length > 0 || this.faceUp.length > 0 || this.faceDown.length > 0;
            }

            getPlayableCards() {
                if (this.hand.length > 0) return this.hand;
                if (this.faceUp.length > 0) return this.faceUp;
                if (this.faceDown.length > 0) return this.faceDown;
                return [];
            }

            isPlayingBlind() {
                return this.hand.length === 0 && this.faceUp.length === 0 && this.faceDown.length > 0;
            }
        }

        // Lobby functions
        function createRoom() {
            const playerName = document.getElementById('player-name').value.trim();
            if (!playerName) {
                alert('Please enter your name');
                return;
            }
            socket.emit('createRoom', playerName);
        }

        function showJoinRoom() {
            document.getElementById('initial-choice').style.display = 'none';
            document.getElementById('join-room-input').style.display = 'block';
        }

        function showInitialChoice() {
            document.getElementById('initial-choice').style.display = 'block';
            document.getElementById('join-room-input').style.display = 'none';
        }

        function joinRoom() {
            const playerName = document.getElementById('player-name').value.trim();
            const roomCodeInput = document.getElementById('room-code-input').value.trim().toUpperCase();

            if (!playerName || !roomCodeInput) {
                alert('Please enter your name and room code');
                return;
            }

            socket.emit('joinRoom', { roomCode: roomCodeInput, playerName });
        }

        function markReady() {
            socket.emit('playerReady', roomCode);
            document.getElementById('ready-btn').disabled = true;
            document.getElementById('ready-btn').textContent = 'Ready ✓';
        }

        // Socket event handlers
        socket.on('roomCreated', (data) => {
            myPlayerId = data.playerId;
            roomCode = data.roomCode;
            showWaitingRoom();
        });

        socket.on('roomJoined', (data) => {
            myPlayerId = data.playerId;
            roomCode = data.roomCode;
            showWaitingRoom();
        });

        socket.on('playersUpdate', (players) => {
            roomPlayers = players;
            updatePlayersList();
        });

        socket.on('gameStart', (players) => {
            // Initialize game with room players
            game.players = players.map(p => new Player(p.name, p.id));
            myPlayerIndex = game.players.findIndex(p => p.id === myPlayerId);

            // Hide lobby, start game
            document.getElementById('lobby-screen').style.display = 'none';
            document.getElementById('game-table').style.display = 'block';

            // Create player areas
            createPlayerAreas();

            // Initialize and deal cards (only host does this)
            if (myPlayerIndex === 0) {
                initializeAndDealCards();
            }
        });

        socket.on('gameStateChanged', (newGameState) => {
            // Reconstruct card objects
            game = deserializeGameState(newGameState);

            // Check if I need to select face-up cards (if I haven't already)
            const myPlayer = game.players[myPlayerIndex];
            if (game.setupPhase === 'faceup' && myPlayer && myPlayer.faceUp.length === 0 && myPlayer.hand.length === 6) {
                showFaceUpSelection();
            }

            updateDisplay();
        });

        socket.on('error', (message) => {
            alert(message);
        });

        socket.on('playerDisconnected', (playerId) => {
            showMessage('A player disconnected');
        });

        function showWaitingRoom() {
            document.getElementById('initial-choice').style.display = 'none';
            document.getElementById('join-room-input').style.display = 'none';
            document.getElementById('waiting-room').style.display = 'block';
            document.getElementById('room-code-display').textContent = `Room Code: ${roomCode}`;
        }

        function updatePlayersList() {
            const list = document.getElementById('players-list');
            list.innerHTML = roomPlayers.map(p =>
                `<div class="player-item ${p.ready ? 'ready' : ''}">${p.name} ${p.ready ? '✓' : ''}</div>`
            ).join('');
        }

        function createPlayerAreas() {
            const gameTable = document.getElementById('game-table');
            for (let i = 0; i < game.players.length; i++) {
                const playerArea = document.createElement('div');
                playerArea.id = `player-${i}`;
                playerArea.className = 'player-area';
                gameTable.appendChild(playerArea);
            }
        }

        function initializeAndDealCards() {
            // Initialize deck
            game.deck = [];
            for (let suit of SUITS) {
                for (let rank = 2; rank <= 14; rank++) {
                    game.deck.push(new Card(rank, suit));
                }
            }
            shuffleDeck();

            // Deal cards
            for (let player of game.players) {
                player.faceDown = [drawCard(), drawCard(), drawCard()];
            }

            for (let player of game.players) {
                for (let i = 0; i < 6; i++) {
                    player.hand.push(drawCard());
                }
            }

            game.setupPhase = 'faceup';
            game.setupPlayerIdx = 0;

            // Sync state to all players
            broadcastGameState();

            // Show face-up selection for me if I'm first
            if (myPlayerIndex === 0) {
                showFaceUpSelection();
            }
        }

        function shuffleDeck() {
            for (let i = game.deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [game.deck[i], game.deck[j]] = [game.deck[j], game.deck[i]];
            }
        }

        function drawCard() {
            return game.deck.pop();
        }

        function drawCards(player) {
            while (player.hand.length < 3 && game.deck.length > 0) {
                player.hand.push(drawCard());
            }
        }

        function showFaceUpSelection() {
            const player = game.players[myPlayerIndex];
            document.getElementById('faceup-player-name').textContent = `${player.name} - Choose Face-Up Cards`;

            const cardsContainer = document.getElementById('faceup-cards');
            cardsContainer.innerHTML = '';

            player.hand.forEach((card, idx) => {
                const cardEl = createCardElement(card, () => {
                    if (game.selectedCards.includes(idx)) {
                        game.selectedCards = game.selectedCards.filter(i => i !== idx);
                        cardEl.classList.remove('selected');
                    } else {
                        if (game.selectedCards.length < 3) {
                            game.selectedCards.push(idx);
                            cardEl.classList.add('selected');
                        }
                    }
                });
                cardsContainer.appendChild(cardEl);
            });

            game.selectedCards = [];
            document.getElementById('setup-faceup').style.display = 'block';
        }

        function confirmFaceUp() {
            if (game.selectedCards.length !== 3) {
                alert('Please select exactly 3 cards');
                return;
            }

            const player = game.players[myPlayerIndex];
            const selectedIndices = [...game.selectedCards].sort((a, b) => b - a);
            for (let idx of selectedIndices) {
                player.faceUp.push(player.hand[idx]);
                player.hand.splice(idx, 1);
            }

            game.selectedCards = [];
            document.getElementById('setup-faceup').style.display = 'none';

            // Check if all players have selected their face-up cards
            const allPlayersDone = game.players.every(p => p.faceUp.length === 3);

            if (allPlayersDone) {
                // All players done
                game.setupPhase = 'done';
                showMessage(`Game started! ${game.players[game.currentPlayerIdx].name}'s turn`);
            }

            // Broadcast updated state
            broadcastGameState();

            updateDisplay();
        }

        function createCardElement(card, onClick, faceDown = false) {
            const cardEl = document.createElement('div');
            cardEl.className = `card ${card.isRed() ? 'red' : 'black'}`;
            if (faceDown) {
                cardEl.className += ' face-down';
            } else {
                cardEl.textContent = card.toString();
            }
            if (onClick) {
                cardEl.onclick = onClick;
            }
            return cardEl;
        }

        function updateDisplay() {
            if (game.setupPhase !== 'done') return;

            // Show face-up selection if it's my turn during setup
            if (game.setupPhase === 'faceup' && game.setupPlayerIdx === myPlayerIndex) {
                showFaceUpSelection();
                return;
            }

            // Always show whose turn it is
            if (game.currentPlayerIdx >= 0 && game.players[game.currentPlayerIdx]) {
                const currentPlayer = game.players[game.currentPlayerIdx];
                const isMyTurn = game.currentPlayerIdx === myPlayerIndex;
                showMessage(isMyTurn ? "Your turn!" : `${currentPlayer.name}'s turn`);
            }

            // Update deck visual
            const deckVisual = document.getElementById('deck-visual');
            deckVisual.innerHTML = '';
            if (game.deck.length > 0) {
                for (let i = 0; i < 3; i++) {
                    const cardEl = document.createElement('div');
                    cardEl.className = 'card face-down';
                    cardEl.style.transform = `translate(${i * 2}px, ${i * 2}px)`;
                    cardEl.style.zIndex = i;
                    deckVisual.appendChild(cardEl);
                }
            }
            document.getElementById('deck-info').textContent = `Deck: ${game.deck.length} cards`;

            // Update pile
            const pileEl = document.getElementById('pile');
            pileEl.innerHTML = '';
            if (game.pile.length > 0) {
                const cardsToShow = Math.min(5, game.pile.length);
                const startIdx = game.pile.length - cardsToShow;

                for (let i = startIdx; i < game.pile.length; i++) {
                    const card = game.pile[i];
                    const cardEl = createCardElement(card, null);
                    const offset = (i - startIdx) * 3;
                    cardEl.style.transform = `translate(${offset}px, ${offset}px)`;
                    cardEl.style.zIndex = i;
                    pileEl.appendChild(cardEl);
                }
            }
            document.getElementById('pile-info').textContent = `Pile: ${game.pile.length} cards`;

            // Update players
            game.players.forEach((player, idx) => {
                const playerArea = document.getElementById(`player-${idx}`);
                if (!playerArea) return;

                playerArea.className = 'player-area';

                if (idx === game.currentPlayerIdx) {
                    playerArea.classList.add('current-turn');
                }
                if (game.aceAttackTarget === idx) {
                    playerArea.classList.add('under-attack');
                }
                if (game.waitingForTarget && idx !== myPlayerIndex) {
                    playerArea.classList.add('targetable');
                }

                let html = `<div class="player-name">${player.name}</div>`;

                // Stacked cards
                if (player.faceDown.length > 0 || player.faceUp.length > 0) {
                    html += `<div class="card-section">
                        <div class="card-section-label">Table Cards:</div>
                        <div class="card-stack-container" id="player-${idx}-stacks"></div>
                    </div>`;
                }

                // Hand cards (only show for me)
                if (idx === myPlayerIndex) {
                    html += `<div class="card-section">
                        <div class="card-section-label">Hand: ${player.hand.length}</div>
                        <div class="player-cards" id="player-${idx}-hand"></div>
                    </div>`;
                } else {
                    html += `<div class="card-section">
                        <div class="card-section-label">Hand: ${player.hand.length} cards</div>
                    </div>`;
                }

                playerArea.innerHTML = html;

                // Add stacked cards
                const stacksContainer = document.getElementById(`player-${idx}-stacks`);
                if (stacksContainer) {
                    const maxStacks = Math.max(player.faceDown.length, player.faceUp.length);
                    for (let i = 0; i < maxStacks; i++) {
                        const stack = document.createElement('div');
                        stack.className = 'card-stack';

                        if (i < player.faceDown.length) {
                            const faceDownCard = createCardElement(player.faceDown[i],
                                idx === myPlayerIndex && player.hand.length === 0 && player.faceUp.length === 0
                                ? () => selectCard(idx, 'faceDown', i) : null,
                                true);
                            stack.appendChild(faceDownCard);
                        }

                        if (i < player.faceUp.length) {
                            const faceUpCard = createCardElement(player.faceUp[i],
                                idx === myPlayerIndex && player.hand.length === 0
                                ? () => selectCard(idx, 'faceUp', i) : null);
                            faceUpCard.classList.add('face-up');
                            stack.appendChild(faceUpCard);
                        }

                        stacksContainer.appendChild(stack);
                    }
                }

                // Add hand cards (only for me)
                if (idx === myPlayerIndex) {
                    const handContainer = document.getElementById(`player-${idx}-hand`);
                    if (handContainer) {
                        player.hand.forEach((card, cardIdx) => {
                            const cardEl = createCardElement(card, () => selectCard(idx, 'hand', cardIdx));
                            handContainer.appendChild(cardEl);
                        });
                    }
                }
            });

            updateSelectedCards();
            updateControls();
        }

        function selectCard(playerIdx, location, cardIdx) {
            if (playerIdx !== myPlayerIndex) return;
            if (game.currentPlayerIdx !== myPlayerIndex) return;
            if (game.waitingForTarget) return;

            const player = game.players[playerIdx];
            const playableCards = player.getPlayableCards();

            const isPlayable = (location === 'hand' && player.hand.length > 0) ||
                             (location === 'faceUp' && player.hand.length === 0 && player.faceUp.length > 0) ||
                             (location === 'faceDown' && player.hand.length === 0 && player.faceUp.length === 0);

            if (!isPlayable) return;

            const card = location === 'hand' ? player.hand[cardIdx] :
                        location === 'faceUp' ? player.faceUp[cardIdx] :
                        player.faceDown[cardIdx];

            const cardKey = `${location}-${cardIdx}`;
            const selectedIdx = game.selectedCards.findIndex(c => c.key === cardKey);

            if (selectedIdx >= 0) {
                game.selectedCards.splice(selectedIdx, 1);
            } else {
                if (game.selectedCards.length > 0) {
                    const firstRank = game.selectedCards[0].card.rank;
                    if (card.rank !== firstRank) {
                        game.selectedCards = [];
                    }
                }
                game.selectedCards.push({ card, location, idx: cardIdx, key: cardKey });
            }

            updateDisplay();
        }

        function updateSelectedCards() {
            game.selectedCards.forEach(({ location, idx }) => {
                const containers = location === 'hand' ? [`player-${myPlayerIndex}-hand`] :
                                 location === 'faceUp' ? [`player-${myPlayerIndex}-stacks`] : [];
                containers.forEach(containerId => {
                    const container = document.getElementById(containerId);
                    if (container && container.children[idx]) {
                        container.children[idx].classList.add('selected');
                    }
                });
            });
        }

        function updateControls() {
            const playBtn = document.getElementById('play-btn');
            const pickupBtn = document.getElementById('pickup-btn');

            const canPlay = game.selectedCards.length > 0 &&
                          game.currentPlayerIdx === myPlayerIndex &&
                          !game.waitingForTarget;

            playBtn.disabled = !canPlay;
            pickupBtn.disabled = game.currentPlayerIdx !== myPlayerIndex || game.waitingForTarget || game.pile.length === 0;
        }

        function canPlayCard(card, isDefendingAce = false) {
            if (game.pile.length === 0) return true;

            if (isDefendingAce) {
                return [Rank.TWO, Rank.TEN, Rank.THREE, Rank.ACE].includes(card.rank);
            }

            if ([Rank.TEN, Rank.TWO, Rank.THREE, Rank.ACE].includes(card.rank)) {
                return true;
            }

            const topRank = game.pile[game.pile.length - 1].rank;

            if (topRank === Rank.SEVEN) {
                return card.rank <= Rank.SEVEN;
            }

            return card.rank >= topRank;
        }

        function playCards() {
            if (game.selectedCards.length === 0) return;
            if (game.currentPlayerIdx !== myPlayerIndex) return;
            if (game.waitingForTarget) return;

            const player = game.players[myPlayerIndex];
            const cards = game.selectedCards.map(c => c.card);
            const isDefendingAce = game.aceAttackTarget === myPlayerIndex;
            const isBlind = player.isPlayingBlind();

            // Check if playing blind card that can't be played
            if (isBlind && cards.length > 0) {
                const blindCard = cards[0];
                if (!canPlayCard(blindCard, isDefendingAce)) {
                    // Remove the blind card from face-down
                    const sortedSelected = [...game.selectedCards].sort((a, b) => b.idx - a.idx);
                    for (let { location, idx } of sortedSelected) {
                        if (location === 'faceDown') {
                            player.faceDown.splice(idx, 1);
                        }
                    }

                    // Add blind card to hand and pick up pile
                    player.hand.push(blindCard);
                    player.hand.push(...game.pile);
                    showMessage(`${player.name} played ${blindCard.toString()} blind - can't play! Picks up pile with the card.`);
                    game.pile = [];
                    game.aceAttackTarget = null;
                    game.selectedCards = [];
                    nextTurn();
                    return;
                }
            }

            // Validate non-blind cards
            if (!isBlind) {
                for (let card of cards) {
                    if (!canPlayCard(card, isDefendingAce)) {
                        showMessage(`Cannot play ${card.toString()}!`);
                        return;
                    }
                }
            }

            // Remove cards from player
            const sortedSelected = [...game.selectedCards].sort((a, b) => b.idx - a.idx);
            for (let { location, idx } of sortedSelected) {
                if (location === 'hand') {
                    game.pile.push(player.hand.splice(idx, 1)[0]);
                } else if (location === 'faceUp') {
                    game.pile.push(player.faceUp.splice(idx, 1)[0]);
                } else if (location === 'faceDown') {
                    game.pile.push(player.faceDown.splice(idx, 1)[0]);
                }
            }

            game.selectedCards = [];

            const playedRank = cards[0].rank;
            const numCards = cards.length;

            showMessage(`${player.name} plays ${cards.map(c => c.toString()).join(', ')}`);

            // Handle special cards
            if (playedRank === Rank.ACE && !isDefendingAce) {
                game.waitingForTarget = true;
                showMessage('Choose a player to attack!');
                broadcastGameState();
                updateDisplay();
                return;
            }

            if (playedRank === Rank.ACE && isDefendingAce) {
                game.waitingForTarget = true;
                showMessage(`${player.name} counters with Ace! Choose a player to attack!`);
                broadcastGameState();
                updateDisplay();
                return;
            }

            if (playedRank === Rank.TWO && isDefendingAce) {
                showMessage(`${player.name} blocks with 2!`);
                game.aceAttackTarget = null;
            }

            // Handle 3 (mirrors card below)
            if (playedRank === Rank.THREE && game.pile.length >= 2) {
                const cardBelow = game.pile[game.pile.length - 2];
                showMessage(`${player.name} mirrors ${cardBelow.toString()} with 3!`);

                // Apply the effect of the card below
                if (cardBelow.rank === Rank.ACE) {
                    game.waitingForTarget = true;
                    showMessage(`${player.name} mirrors Ace! Choose a player to attack!`);
                    broadcastGameState();
                    updateDisplay();
                    return;
                } else if (cardBelow.rank === Rank.EIGHT) {
                    // Mirror 8's skip effect
                    game.skipsRemaining += numCards;
                    showMessage(`⏭️ 3 mirrors 8! ${numCards} more turn(s) skipped!`);
                } else if (cardBelow.rank === Rank.TEN) {
                    // Mirror 10's burn effect
                    showMessage(`🔥 3 mirrors 10! ${player.name} burns the pile and plays again!`);
                    game.pile = [];
                    game.aceAttackTarget = null;
                    drawCards(player);
                    broadcastGameState();
                    updateDisplay();
                    return;
                }
            }

            if (playedRank === Rank.TEN) {
                game.aceAttackTarget = null;
            }

            if (checkForBurn()) {
                showMessage(`🔥 BURN! ${player.name} plays again!`);
                game.pile = [];
                game.aceAttackTarget = null;
                drawCards(player);
                broadcastGameState();
                updateDisplay();
                return;
            }

            if (playedRank === Rank.EIGHT) {
                game.skipsRemaining = numCards;
                showMessage(`⏭️ Next ${numCards} turn(s) skipped!`);
            }

            if (isDefendingAce) {
                game.aceAttackTarget = null;
            }

            if (!player.hasCards()) {
                showMessage(`🎉 ${player.name} wins!`);
                broadcastGameState();
                updateDisplay();
                return;
            }

            drawCards(player);
            nextTurn();
        }

        function checkForBurn() {
            if (game.pile.length === 0) return false;

            if (game.pile[game.pile.length - 1].rank === Rank.TEN) {
                return true;
            }

            if (game.pile.length >= 4) {
                const lastFour = game.pile.slice(-4);
                if (lastFour.every(c => c.rank === lastFour[0].rank)) {
                    return true;
                }
            }

            return false;
        }

        function nextTurn() {
            if (game.skipsRemaining > 0 && game.aceAttackTarget === null) {
                game.skipsRemaining--;
                game.currentPlayerIdx = (game.currentPlayerIdx + 1) % game.players.length;
                showMessage(`${game.players[game.currentPlayerIdx].name}'s turn skipped!`);
                if (game.skipsRemaining > 0 || game.aceAttackTarget !== null) {
                    broadcastGameState();
                    updateDisplay();
                    setTimeout(nextTurn, 1500);
                    return;
                }
            }

            game.currentPlayerIdx = (game.currentPlayerIdx + 1) % game.players.length;

            game.players = game.players.filter(p => p.hasCards());
            if (game.players.length <= 1) {
                showMessage('Game Over!');
                broadcastGameState();
                updateDisplay();
                return;
            }

            game.currentPlayerIdx = game.currentPlayerIdx % game.players.length;

            showMessage(`${game.players[game.currentPlayerIdx].name}'s turn`);
            broadcastGameState();
            updateDisplay();
        }

        function pickupPile() {
            if (game.currentPlayerIdx !== myPlayerIndex) return;

            const player = game.players[myPlayerIndex];
            player.hand.push(...game.pile);
            showMessage(`${player.name} picks up ${game.pile.length} cards`);
            game.pile = [];
            game.aceAttackTarget = null;
            game.selectedCards = [];
            nextTurn();
        }

        function showMessage(msg) {
            const messagesEl = document.getElementById('messages');
            messagesEl.innerHTML = `<span class="message-highlight">${msg}</span>`;
        }

        // Add click handlers for player targeting
        document.addEventListener('click', (e) => {
            const playerArea = e.target.closest('.player-area.targetable');
            if (playerArea && game.waitingForTarget && game.currentPlayerIdx === myPlayerIndex) {
                const playerIdx = parseInt(playerArea.id.split('-')[1]);
                targetPlayer(playerIdx);
            }
        });

        function targetPlayer(targetIdx) {
            if (!game.waitingForTarget) return;
            if (targetIdx === myPlayerIndex) return;
            if (game.currentPlayerIdx !== myPlayerIndex) return;

            const attacker = game.players[myPlayerIndex];
            const target = game.players[targetIdx];

            game.aceAttackTarget = targetIdx;
            game.waitingForTarget = false;

            showMessage(`${attacker.name} attacks ${target.name}!`);

            drawCards(attacker);
            game.currentPlayerIdx = targetIdx;
            broadcastGameState();
            updateDisplay();
        }

        // Broadcast game state to all players
        function broadcastGameState() {
            const serialized = serializeGameState(game);
            socket.emit('gameStateUpdate', { roomCode, gameState: serialized });
        }

        // Serialize game state for transmission
        function serializeGameState(state) {
            return JSON.stringify(state);
        }

        // Deserialize game state
        function deserializeGameState(serialized) {
            const obj = JSON.parse(serialized);

            // Reconstruct Card objects
            obj.deck = obj.deck.map(c => new Card(c.rank, c.suit));
            obj.pile = obj.pile.map(c => new Card(c.rank, c.suit));
            obj.players = obj.players.map(p => {
                const player = new Player(p.name, p.id);
                player.hand = p.hand.map(c => new Card(c.rank, c.suit));
                player.faceUp = p.faceUp.map(c => new Card(c.rank, c.suit));
                player.faceDown = p.faceDown.map(c => new Card(c.rank, c.suit));
                return player;
            });

            return obj;
        }
    </script>
</body>
</html>
