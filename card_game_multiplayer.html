<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Card Game - Multiplayer</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
        }

        #game-container {
            width: 95vw;
            max-width: 1400px;
            height: 95vh;
            position: relative;
        }

        /* Lobby screen */
        #lobby-screen {
            background: rgba(0, 0, 0, 0.8);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            min-width: 400px;
        }

        #lobby-screen h1 {
            font-size: 48px;
            margin-bottom: 30px;
            color: #ffd700;
        }

        #lobby-screen input {
            width: 100%;
            padding: 10px;
            font-size: 18px;
            margin-bottom: 20px;
            border-radius: 5px;
            border: none;
        }

        #lobby-screen button {
            padding: 15px 40px;
            font-size: 20px;
            background: #ffd700;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
            margin: 10px;
        }

        #lobby-screen button:hover {
            transform: scale(1.05);
        }

        #room-code-display {
            font-size: 32px;
            color: #ffd700;
            font-weight: bold;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 215, 0, 0.2);
            border-radius: 10px;
        }

        #players-list {
            text-align: left;
            margin: 20px 0;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
        }

        .player-item {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        .player-item.ready {
            background: rgba(76, 175, 80, 0.3);
        }

        /* Include all styles from original card_game.html */
        #game-table {
            display: none;
            width: 100%;
            height: 100%;
            position: relative;
        }

        #center-area {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: flex;
            gap: 40px;
            align-items: center;
            z-index: 50;
        }

        #deck-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #deck-visual {
            position: relative;
            width: 70px;
            height: 100px;
            margin-bottom: 10px;
        }

        #deck-visual .card {
            position: absolute;
        }

        #pile-container {
            min-width: 150px;
            min-height: 200px;
            background: rgba(0, 0, 0, 0.3);
            border: 3px dashed rgba(255, 255, 255, 0.5);
            border-radius: 10px;
            padding: 20px;
            position: relative;
        }

        #pile {
            position: relative;
            min-height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #pile .card {
            position: absolute;
        }

        #pile .card:last-child {
            z-index: 100;
        }

        #pile-info, #deck-info {
            margin-top: 10px;
            font-size: 14px;
            opacity: 0.8;
        }

        .card {
            width: 70px;
            height: 100px;
            background: white;
            border: 2px solid #333;
            border-radius: 8px;
            display: inline-flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            user-select: none;
        }

        .card:hover {
            transform: translateY(-10px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
        }

        .card.selected {
            transform: translateY(-20px);
            box-shadow: 0 10px 30px rgba(255, 215, 0, 0.8);
            border-color: #ffd700;
        }

        .card.red {
            color: #d32f2f;
        }

        .card.black {
            color: #333;
        }

        .card.face-down {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: transparent;
        }

        .card.face-down::after {
            content: '🂠';
            position: absolute;
            font-size: 40px;
            color: white;
        }

        .player-area {
            position: absolute;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            min-width: 250px;
        }

        .player-area.current-turn {
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .player-area.under-attack {
            border-color: #ff4444;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.8);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 68, 68, 0.8); }
            50% { box-shadow: 0 0 30px rgba(255, 68, 68, 1); }
        }

        .player-area.targetable {
            border-color: #ff6b6b;
            cursor: pointer;
        }

        .player-area.targetable:hover {
            border-color: #ff0000;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
        }

        .player-name {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #ffd700;
        }

        .player-cards {
            display: flex;
            gap: 5px;
            flex-wrap: nowrap;
            margin-top: 10px;
            overflow-x: auto;
            max-width: 100%;
            padding-bottom: 5px;
        }

        .player-cards::-webkit-scrollbar {
            height: 6px;
        }

        .player-cards::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .player-cards::-webkit-scrollbar-thumb {
            background: rgba(255, 215, 0, 0.5);
            border-radius: 3px;
        }

        .card-section {
            margin-bottom: 10px;
        }

        .card-section-label {
            font-size: 12px;
            opacity: 0.7;
            margin-bottom: 5px;
        }

        .card-stack {
            display: inline-block;
            position: relative;
            margin-right: 15px;
        }

        .card-stack .card.face-down {
            position: relative;
            z-index: 1;
        }

        .card-stack .card.face-up {
            position: absolute;
            top: -30px;
            left: 0;
            z-index: 2;
        }

        .card-stack-container {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            min-height: 130px;
        }

        #player-0 { bottom: 5px; left: 35%; transform: translateX(-50%); max-width: 380px; }
        #player-1 { top: 20px; left: 20px; max-width: 280px; }
        #player-2 { top: 20px; right: 20px; max-width: 280px; }
        #player-3 { bottom: 20px; left: 20px; max-width: 280px; }
        #player-4 { bottom: 20px; right: 20px; max-width: 280px; }
        #player-5 { top: 50%; left: 5px; transform: translateY(-50%); max-width: 280px; }

        #controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 500;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        #play-btn {
            background: #4caf50;
            color: white;
        }

        #play-btn:hover:not(:disabled) {
            background: #45a049;
        }

        #play-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        #pickup-btn {
            background: #f44336;
            color: white;
        }

        #pickup-btn:hover:not(:disabled) {
            background: #da190b;
        }

        #messages {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 18px;
            max-width: 600px;
            text-align: center;
            z-index: 100;
        }

        .message-highlight {
            color: #ffd700;
            font-weight: bold;
        }

        #setup-faceup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 1000;
            display: none;
        }

        #setup-faceup h2 {
            margin-bottom: 20px;
            color: #ffd700;
        }

        #setup-faceup .player-cards {
            justify-content: center;
            margin: 20px 0;
        }

        #setup-faceup button {
            background: #ffd700;
            color: #333;
            margin-top: 20px;
        }

        /* Winner celebration */
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            background: #ffd700;
            position: absolute;
            animation: confetti-fall 3s linear forwards;
        }

        @keyframes confetti-fall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }

        #winner-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        #winner-message {
            text-align: center;
            animation: bounceIn 0.6s;
        }

        @keyframes bounceIn {
            0% { transform: scale(0); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        #winner-message h1 {
            font-size: 72px;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            margin-bottom: 20px;
        }

        #winner-message p {
            font-size: 32px;
            color: white;
        }

        #attack-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 68, 68, 0.95);
            padding: 30px 50px;
            border-radius: 20px;
            border: 3px solid #ff0000;
            font-size: 28px;
            font-weight: bold;
            color: white;
            text-align: center;
            z-index: 1500;
            display: none;
            box-shadow: 0 0 40px rgba(255, 0, 0, 0.8);
            animation: pulse-popup 1s infinite;
        }

        @keyframes pulse-popup {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.05); }
        }

        #turn-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 215, 0, 0.95);
            padding: 40px 60px;
            border-radius: 20px;
            border: 4px solid #ffd700;
            font-size: 36px;
            font-weight: bold;
            color: #000;
            text-align: center;
            z-index: 1500;
            display: none;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
            animation: shake 0.5s infinite;
        }

        @keyframes shake {
            0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
            25% { transform: translate(-50%, -50%) rotate(-3deg); }
            75% { transform: translate(-50%, -50%) rotate(3deg); }
        }

        @media (max-width: 768px) {
            #game-container {
                width: 100vw;
                height: 100vh;
            }

            #center-area {
                top: 25%;
                transform: scale(0.7);
            }

            #messages {
                font-size: 14px;
                top: 5px;
            }

            .card {
                width: 50px;
                height: 70px;
                font-size: 18px;
            }

            .player-area {
                padding: 8px;
                min-width: 150px;
                font-size: 12px;
            }

            .player-name {
                font-size: 14px;
                margin-bottom: 5px;
            }

            #player-0 {
                bottom: 60px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 90%;
            }
            #player-1 {
                top: 10px;
                left: 5px;
                max-width: 30%;
            }
            #player-2 {
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 30%;
            }
            #player-3 {
                top: 10px;
                right: 5px;
                max-width: 30%;
            }
            #player-4 {
                top: 50%;
                left: 5px;
                transform: translateY(-50%);
                max-width: 30%;
            }
            #player-5 {
                top: 50%;
                right: 5px;
                transform: translateY(-50%);
                max-width: 30%;
            }

            #controls {
                position: fixed;
                bottom: 5px;
                left: 50%;
                transform: translateX(-50%);
                right: auto;
                gap: 10px;
                z-index: 500;
            }

            button {
                padding: 12px 20px;
                font-size: 16px;
                flex: 1;
            }

            .card-stack-container {
                gap: 10px;
                min-height: 80px;
            }

            .card-stack {
                margin-right: 8px;
            }

            #lobby-screen {
                padding: 20px;
                min-width: 90vw;
            }

            #lobby-screen h1 {
                font-size: 32px;
            }

            #attack-popup {
                font-size: 20px;
                padding: 20px 30px;
            }

            #turn-popup {
                font-size: 24px;
                padding: 25px 35px;
            }

            #winner-video {
                width: 90vw;
                max-width: 400px;
                height: 225px;
            }
        }

        @media (max-width: 768px) and (orientation: landscape) {
            #center-area {
                top: 50%;
                transform: translateY(-50%) scale(0.6);
            }

            #player-0 {
                bottom: 55px;
                left: 50%;
                transform: translateX(-50%);
                max-width: 40%;
            }

            #player-1 {
                top: 5px;
                left: 5px;
                max-width: 25%;
            }

            #player-2 {
                top: 5px;
                right: 5px;
                max-width: 25%;
            }

            #player-3 {
                bottom: 55px;
                left: 5px;
                max-width: 25%;
            }

            #player-4 {
                bottom: 55px;
                right: 5px;
                max-width: 25%;
            }

            #player-5 {
                top: 50%;
                left: 5px;
                transform: translateY(-50%);
                max-width: 25%;
            }

            .player-area {
                padding: 5px;
                min-width: 120px;
                font-size: 10px;
            }

            .player-name {
                font-size: 12px;
            }

            .card {
                width: 40px;
                height: 56px;
                font-size: 14px;
            }

            button {
                padding: 10px 15px;
                font-size: 14px;
            }

            #controls {
                position: fixed;
                bottom: 5px;
                left: 50%;
                transform: translateX(-50%);
                gap: 8px;
                z-index: 500;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Lobby Screen -->
        <div id="lobby-screen">
            <h1>🃏 Card Game</h1>

            <div id="initial-choice">
                <input type="text" id="player-name" placeholder="Enter your name" maxlength="20">
                <br>
                <div style="margin: 15px 0;">
                    <label style="font-size: 16px; cursor: pointer;">
                        <input type="checkbox" id="allow-lying" style="margin-right: 8px; cursor: pointer;">
                        Allow Lying
                    </label>
                </div>
                <button onclick="createRoom()">Create New Game</button>
                <button onclick="showJoinRoom()">Join Game</button>
            </div>

            <div id="join-room-input" style="display: none;">
                <input type="text" id="room-code-input" placeholder="Enter room code" maxlength="6" style="text-transform: uppercase;">
                <br>
                <button onclick="joinRoom()">Join</button>
                <button onclick="showInitialChoice()">Back</button>
            </div>

            <div id="waiting-room" style="display: none;">
                <div id="room-code-display"></div>
                <h3>Players in Lobby:</h3>
                <div id="players-list"></div>
                <button id="ready-btn" onclick="markReady()">Ready!</button>
                <p style="margin-top: 20px; font-size: 14px; opacity: 0.7;">Waiting for all players to be ready...</p>
            </div>
        </div>

        <!-- Face-up card selection -->
        <div id="setup-faceup">
            <h2 id="faceup-player-name">Choose Face-Up Cards</h2>
            <p>Select 3 cards to place face-up (click to select/deselect)</p>
            <div class="player-cards" id="faceup-cards"></div>
            <button onclick="confirmFaceUp()">Confirm Selection</button>
        </div>

        <!-- Winner Overlay -->
        <div id="winner-overlay">
            <div id="winner-message">
                <h1>🎉 WINNER! 🎉</h1>
                <p id="winner-name"></p>
                <iframe id="winner-video" width="560" height="315" style="margin-top: 20px; border-radius: 10px;"
                    src="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                    allowfullscreen></iframe>
            </div>
        </div>

        <div id="attack-popup">
            👉 Press on player to attack! 👈
        </div>

        <div id="turn-popup">
            IT'S YOUR TURN ASSHOLE!
        </div>

        <!-- Game Table -->
        <div id="game-table">
            <div id="messages"></div>

            <div id="center-area">
                <div id="deck-container">
                    <div id="deck-visual"></div>
                    <div id="deck-info">Deck: 0 cards</div>
                </div>

                <div id="pile-container">
                    <div id="pile"></div>
                    <div id="pile-info">Pile: 0 cards</div>
                </div>
            </div>

            <div id="controls">
                <button id="play-btn" onclick="playCards(false)" disabled>Play Selected Cards</button>
                <button id="play-facedown-btn" onclick="playCards(true)" disabled style="background: #9b59b6; display: none;">🃏 Play Face Down</button>
                <button id="pickup-btn" onclick="pickupPile()" disabled>Pick Up Pile</button>
                <button id="lie-btn" onclick="callLie()" disabled style="background: #ff6b6b; display: none;">🤥 Call Lie!</button>
            </div>
        </div>
    </div>

    <script>
        // Socket.io connection
        const socket = io();

        // Game constants
        const Rank = {
            TWO: 2, THREE: 3, FOUR: 4, FIVE: 5, SIX: 6, SEVEN: 7, EIGHT: 8,
            NINE: 9, TEN: 10, JACK: 11, QUEEN: 12, KING: 13, ACE: 14
        };

        const RANK_NAMES = {
            2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8',
            9: '9', 10: '10', 11: 'J', 12: 'Q', 13: 'K', 14: 'A'
        };

        const SUITS = ['♠', '♥', '♦', '♣'];

        // Multiplayer state
        let myPlayerId = null;
        let myPlayerIndex = null;
        let roomCode = null;
        let roomPlayers = [];

        // Game state (will be synced across all players)
        let game = {
            players: [],
            deck: [],
            pile: [],
            currentPlayerIdx: 0,
            skipsRemaining: 0,
            aceAttackTarget: null,
            selectedCards: [],
            setupPhase: 'init',
            setupPlayerIdx: 0,
            waitingForTarget: false,
            mirroredRank: null,
            allowLying: false,
            lastPlayedCards: [],
            declaredCards: [],
            lastPlayerIdx: -1,
            canCallLie: false,
            faceDownIndices: [],
            declaredRanks: {}, // Maps pile index to declared rank
            winnerName: null
        };

        // Card class
        class Card {
            constructor(rank, suit) {
                this.rank = rank;
                this.suit = suit;
            }

            toString() {
                return RANK_NAMES[this.rank] + this.suit;
            }

            isRed() {
                return this.suit === '♥' || this.suit === '♦';
            }
        }

        // Player class
        class Player {
            constructor(name, id) {
                this.name = name;
                this.id = id;
                this.hand = [];
                this.faceUp = [];
                this.faceDown = [];
            }

            hasCards() {
                return this.hand.length > 0 || this.faceUp.length > 0 || this.faceDown.length > 0;
            }

            getPlayableCards() {
                if (this.hand.length > 0) return this.hand;
                if (this.faceUp.length > 0) return this.faceUp;
                if (this.faceDown.length > 0) return this.faceDown;
                return [];
            }

            isPlayingBlind() {
                return this.hand.length === 0 && this.faceUp.length === 0 && this.faceDown.length > 0;
            }
        }

        // Lobby functions
        function createRoom() {
            const playerName = document.getElementById('player-name').value.trim();
            if (!playerName) {
                alert('Please enter your name');
                return;
            }
            const allowLying = document.getElementById('allow-lying').checked;
            game.allowLying = allowLying;
            socket.emit('createRoom', playerName);
        }

        function showJoinRoom() {
            document.getElementById('initial-choice').style.display = 'none';
            document.getElementById('join-room-input').style.display = 'block';
        }

        function showInitialChoice() {
            document.getElementById('initial-choice').style.display = 'block';
            document.getElementById('join-room-input').style.display = 'none';
        }

        function joinRoom() {
            const playerName = document.getElementById('player-name').value.trim();
            const roomCodeInput = document.getElementById('room-code-input').value.trim().toUpperCase();

            if (!playerName || !roomCodeInput) {
                alert('Please enter your name and room code');
                return;
            }

            socket.emit('joinRoom', { roomCode: roomCodeInput, playerName });
        }

        function markReady() {
            socket.emit('playerReady', roomCode);
            document.getElementById('ready-btn').disabled = true;
            document.getElementById('ready-btn').textContent = 'Ready ✓';
        }

        // Socket event handlers
        socket.on('roomCreated', (data) => {
            myPlayerId = data.playerId;
            roomCode = data.roomCode;
            showWaitingRoom();
        });

        socket.on('roomJoined', (data) => {
            myPlayerId = data.playerId;
            roomCode = data.roomCode;
            showWaitingRoom();
        });

        socket.on('playersUpdate', (players) => {
            roomPlayers = players;
            updatePlayersList();
        });

        socket.on('gameStart', (players) => {
            // Initialize game with room players
            game.players = players.map(p => new Player(p.name, p.id));
            myPlayerIndex = game.players.findIndex(p => p.id === myPlayerId);

            // Hide lobby, start game
            document.getElementById('lobby-screen').style.display = 'none';
            document.getElementById('game-table').style.display = 'block';

            // Create player areas
            createPlayerAreas();

            // Initialize and deal cards (only host does this)
            if (myPlayerIndex === 0) {
                initializeAndDealCards();
            }
        });

        socket.on('gameStateChanged', (newGameState) => {
            // Reconstruct card objects
            game = deserializeGameState(newGameState);

            // Check if someone won and show celebration for all players
            if (game.winnerName) {
                showMessage(`🎉 ${game.winnerName} wins!`);
                showWinnerCelebration(game.winnerName);
            }

            // Check if I need to select face-up cards (if I haven't already)
            const myPlayer = game.players[myPlayerIndex];
            if (game.setupPhase === 'faceup' && myPlayer && myPlayer.faceUp.length === 0 && myPlayer.hand.length === 4) {
                showFaceUpSelection();
            }

            updateDisplay();
        });

        socket.on('error', (message) => {
            alert(message);
        });

        socket.on('playerDisconnected', (playerId) => {
            showMessage('A player disconnected');
        });

        function showWaitingRoom() {
            document.getElementById('initial-choice').style.display = 'none';
            document.getElementById('join-room-input').style.display = 'none';
            document.getElementById('waiting-room').style.display = 'block';
            document.getElementById('room-code-display').textContent = `Room Code: ${roomCode}`;
        }

        function updatePlayersList() {
            const list = document.getElementById('players-list');
            list.innerHTML = roomPlayers.map(p =>
                `<div class="player-item ${p.ready ? 'ready' : ''}">${p.name} ${p.ready ? '✓' : ''}</div>`
            ).join('');
        }

        function createPlayerAreas() {
            const gameTable = document.getElementById('game-table');
            for (let i = 0; i < game.players.length; i++) {
                const playerArea = document.createElement('div');
                playerArea.id = `player-${i}`;
                playerArea.className = 'player-area';
                gameTable.appendChild(playerArea);
            }
        }

        function initializeAndDealCards() {
            // Initialize deck with 1 standard deck
            game.deck = [];
            for (let suit of SUITS) {
                for (let rank = 2; rank <= 14; rank++) {
                    game.deck.push(new Card(rank, suit));
                }
            }
            shuffleDeck();

            // Deal cards
            for (let player of game.players) {
                player.faceDown = [drawCard(), drawCard()];
            }

            for (let player of game.players) {
                for (let i = 0; i < 4; i++) {
                    player.hand.push(drawCard());
                }
            }

            game.setupPhase = 'faceup';
            game.setupPlayerIdx = 0;

            // Sync state to all players
            broadcastGameState();

            // Show face-up selection for me if I'm first
            if (myPlayerIndex === 0) {
                showFaceUpSelection();
            }
        }

        function shuffleDeck() {
            for (let i = game.deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [game.deck[i], game.deck[j]] = [game.deck[j], game.deck[i]];
            }
        }

        function drawCard() {
            return game.deck.pop();
        }

        function drawCards(player) {
            while (player.hand.length < 2 && game.deck.length > 0) {
                player.hand.push(drawCard());
            }
        }

        function showFaceUpSelection() {
            const player = game.players[myPlayerIndex];
            document.getElementById('faceup-player-name').textContent = `${player.name} - Choose Face-Up Cards`;

            const cardsContainer = document.getElementById('faceup-cards');
            cardsContainer.innerHTML = '';

            player.hand.forEach((card, idx) => {
                const cardEl = createCardElement(card, () => {
                    if (game.selectedCards.includes(idx)) {
                        game.selectedCards = game.selectedCards.filter(i => i !== idx);
                        cardEl.classList.remove('selected');
                    } else {
                        if (game.selectedCards.length < 2) {
                            game.selectedCards.push(idx);
                            cardEl.classList.add('selected');
                        }
                    }
                });
                cardsContainer.appendChild(cardEl);
            });

            game.selectedCards = [];
            document.getElementById('setup-faceup').style.display = 'block';
        }

        function confirmFaceUp() {
            if (game.selectedCards.length !== 2) {
                alert('Please select exactly 2 cards');
                return;
            }

            const player = game.players[myPlayerIndex];
            const selectedIndices = [...game.selectedCards].sort((a, b) => b - a);
            for (let idx of selectedIndices) {
                player.faceUp.push(player.hand[idx]);
                player.hand.splice(idx, 1);
            }

            game.selectedCards = [];
            document.getElementById('setup-faceup').style.display = 'none';

            // Check if all players have selected their face-up cards
            const allPlayersDone = game.players.every(p => p.faceUp.length === 2);

            if (allPlayersDone) {
                // All players done
                game.setupPhase = 'done';
                showMessage(`Game started! ${game.players[game.currentPlayerIdx].name}'s turn`);
            }

            // Broadcast updated state
            broadcastGameState();

            updateDisplay();
        }

        function createCardElement(card, onClick, faceDown = false) {
            const cardEl = document.createElement('div');
            cardEl.className = `card ${card.isRed() ? 'red' : 'black'}`;
            if (faceDown) {
                cardEl.className += ' face-down';
            } else {
                cardEl.textContent = card.toString();
            }
            if (onClick) {
                cardEl.onclick = onClick;
            }
            return cardEl;
        }

        function updateDisplay() {
            if (game.setupPhase !== 'done') return;

            // Show face-up selection if it's my turn during setup
            if (game.setupPhase === 'faceup' && game.setupPlayerIdx === myPlayerIndex) {
                showFaceUpSelection();
                return;
            }

            // Always show whose turn it is
            if (game.currentPlayerIdx >= 0 && game.players[game.currentPlayerIdx]) {
                const currentPlayer = game.players[game.currentPlayerIdx];
                const isMyTurn = game.currentPlayerIdx === myPlayerIndex;
                showMessage(isMyTurn ? "Your turn!" : `${currentPlayer.name}'s turn`);
            }

            // Update deck visual
            const deckVisual = document.getElementById('deck-visual');
            deckVisual.innerHTML = '';
            if (game.deck.length > 0) {
                for (let i = 0; i < 3; i++) {
                    const cardEl = document.createElement('div');
                    cardEl.className = 'card face-down';
                    cardEl.style.transform = `translate(${i * 2}px, ${i * 2}px)`;
                    cardEl.style.zIndex = i;
                    deckVisual.appendChild(cardEl);
                }
            }
            document.getElementById('deck-info').textContent = `Deck: ${game.deck.length} cards`;

            // Update pile
            const pileEl = document.getElementById('pile');
            pileEl.innerHTML = '';
            if (game.pile.length > 0) {
                const cardsToShow = Math.min(5, game.pile.length);
                const startIdx = game.pile.length - cardsToShow;

                for (let i = startIdx; i < game.pile.length; i++) {
                    const card = game.pile[i];
                    const isFaceDown = game.faceDownIndices.includes(i);
                    const cardEl = createCardElement(card, null, isFaceDown);

                    // Wrapper for positioning
                    const wrapper = document.createElement('div');
                    wrapper.style.cssText = 'position: absolute; display: inline-block; width: 80px; height: 112px;';

                    // If face-down with a declared rank, show the declared rank
                    if (isFaceDown && game.declaredRanks[i]) {
                        const rankLabel = document.createElement('div');
                        rankLabel.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 32px; font-weight: bold; color: gold; text-shadow: 3px 3px 8px black, -2px -2px 4px black, 2px -2px 4px black, -2px 2px 4px black; pointer-events: none; z-index: 10;';
                        rankLabel.textContent = RANK_NAMES[game.declaredRanks[i]];
                        wrapper.appendChild(rankLabel);
                    }

                    wrapper.appendChild(cardEl);

                    const offset = (i - startIdx) * 3;
                    wrapper.style.left = offset + 'px';
                    wrapper.style.top = offset + 'px';
                    wrapper.style.zIndex = i;
                    pileEl.appendChild(wrapper);
                }
            }
            document.getElementById('pile-info').textContent = `Pile: ${game.pile.length} cards`;

            // Update players
            game.players.forEach((player, idx) => {
                const playerArea = document.getElementById(`player-${idx}`);
                if (!playerArea) return;

                playerArea.className = 'player-area';

                if (idx === game.currentPlayerIdx) {
                    playerArea.classList.add('current-turn');
                }
                if (game.aceAttackTarget === idx) {
                    playerArea.classList.add('under-attack');
                }
                if (game.waitingForTarget && idx !== myPlayerIndex) {
                    playerArea.classList.add('targetable');
                }

                let html = `<div class="player-name">${player.name}</div>`;

                // Stacked cards
                if (player.faceDown.length > 0 || player.faceUp.length > 0) {
                    html += `<div class="card-section">
                        <div class="card-section-label">Table Cards:</div>
                        <div class="card-stack-container" id="player-${idx}-stacks"></div>
                    </div>`;
                }

                // Hand cards (only show for me)
                if (idx === myPlayerIndex) {
                    html += `<div class="card-section">
                        <div class="card-section-label">Hand: ${player.hand.length}</div>
                        <div class="player-cards" id="player-${idx}-hand"></div>
                    </div>`;
                } else {
                    html += `<div class="card-section">
                        <div class="card-section-label">Hand: ${player.hand.length} cards</div>
                    </div>`;
                }

                playerArea.innerHTML = html;

                // Add stacked cards
                const stacksContainer = document.getElementById(`player-${idx}-stacks`);
                if (stacksContainer) {
                    const maxStacks = Math.max(player.faceDown.length, player.faceUp.length);
                    for (let i = 0; i < maxStacks; i++) {
                        const stack = document.createElement('div');
                        stack.className = 'card-stack';

                        if (i < player.faceDown.length) {
                            const faceDownCard = createCardElement(player.faceDown[i],
                                idx === myPlayerIndex && player.hand.length === 0 && player.faceUp.length === 0
                                ? () => selectCard(idx, 'faceDown', i) : null,
                                true);
                            stack.appendChild(faceDownCard);
                        }

                        if (i < player.faceUp.length) {
                            const faceUpCard = createCardElement(player.faceUp[i],
                                idx === myPlayerIndex && player.hand.length === 0
                                ? () => selectCard(idx, 'faceUp', i) : null);
                            faceUpCard.classList.add('face-up');
                            stack.appendChild(faceUpCard);
                        }

                        stacksContainer.appendChild(stack);
                    }
                }

                // Add hand cards (only for me)
                if (idx === myPlayerIndex) {
                    const handContainer = document.getElementById(`player-${idx}-hand`);
                    if (handContainer) {
                        player.hand.forEach((card, cardIdx) => {
                            const cardEl = createCardElement(card, () => selectCard(idx, 'hand', cardIdx));
                            handContainer.appendChild(cardEl);
                        });
                    }
                }
            });

            updateSelectedCards();
            updateControls();
        }

        function selectCard(playerIdx, location, cardIdx) {
            if (playerIdx !== myPlayerIndex) return;
            if (game.currentPlayerIdx !== myPlayerIndex) return;
            if (game.waitingForTarget) return;

            const player = game.players[playerIdx];
            const playableCards = player.getPlayableCards();

            const isPlayable = (location === 'hand' && player.hand.length > 0) ||
                             (location === 'faceUp' && player.hand.length === 0 && player.faceUp.length > 0) ||
                             (location === 'faceDown' && player.hand.length === 0 && player.faceUp.length === 0);

            if (!isPlayable) return;

            const card = location === 'hand' ? player.hand[cardIdx] :
                        location === 'faceUp' ? player.faceUp[cardIdx] :
                        player.faceDown[cardIdx];

            const cardKey = `${location}-${cardIdx}`;
            const selectedIdx = game.selectedCards.findIndex(c => c.key === cardKey);

            if (selectedIdx >= 0) {
                game.selectedCards.splice(selectedIdx, 1);
            } else {
                if (game.selectedCards.length > 0) {
                    const firstRank = game.selectedCards[0].card.rank;
                    if (card.rank !== firstRank) {
                        game.selectedCards = [];
                    }
                }
                game.selectedCards.push({ card, location, idx: cardIdx, key: cardKey });
            }

            updateDisplay();
        }

        function updateSelectedCards() {
            game.selectedCards.forEach(({ location, idx }) => {
                const containers = location === 'hand' ? [`player-${myPlayerIndex}-hand`] :
                                 location === 'faceUp' ? [`player-${myPlayerIndex}-stacks`] : [];
                containers.forEach(containerId => {
                    const container = document.getElementById(containerId);
                    if (container && container.children[idx]) {
                        container.children[idx].classList.add('selected');
                    }
                });
            });
        }

        function updateControls() {
            const playBtn = document.getElementById('play-btn');
            const playFaceDownBtn = document.getElementById('play-facedown-btn');
            const pickupBtn = document.getElementById('pickup-btn');
            const lieBtn = document.getElementById('lie-btn');

            const canPlay = game.selectedCards.length > 0 &&
                          game.currentPlayerIdx === myPlayerIndex &&
                          !game.waitingForTarget;

            playBtn.disabled = !canPlay;
            pickupBtn.disabled = game.currentPlayerIdx !== myPlayerIndex || game.waitingForTarget || game.pile.length === 0;

            // Show/hide face down button - only for hand and face-up cards, NOT for final face-down cards
            const isPlayingFromFaceDown = game.selectedCards.some(c => c.location === 'faceDown');
            if (game.allowLying && canPlay && !isPlayingFromFaceDown) {
                playFaceDownBtn.style.display = 'block';
                playFaceDownBtn.disabled = false;
            } else {
                playFaceDownBtn.style.display = 'none';
                playFaceDownBtn.disabled = true;
            }

            // Show/hide lie button
            if (game.allowLying && game.canCallLie && game.lastPlayerIdx !== myPlayerIndex && game.lastPlayerIdx >= 0) {
                lieBtn.style.display = 'block';
                lieBtn.disabled = false;
            } else {
                lieBtn.style.display = 'none';
                lieBtn.disabled = true;
            }
        }

        function canPlayCard(card, isDefendingAce = false) {
            if (game.pile.length === 0) return true;

            if (isDefendingAce) {
                return [Rank.TWO, Rank.TEN, Rank.THREE, Rank.ACE].includes(card.rank);
            }

            // If the last card was a 3, use the mirrored rank instead
            const topCard = game.pile[game.pile.length - 1];
            const topCardIndex = game.pile.length - 1;

            // Use declared rank if card was played face-down, otherwise use actual rank
            let topRank = topCard.rank;
            if (game.declaredRanks[topCardIndex]) {
                topRank = game.declaredRanks[topCardIndex];
            } else if (topCard.rank === Rank.THREE && game.mirroredRank) {
                topRank = game.mirroredRank;
            }

            // 7 rule: must play 7 or lower (2, 3, and Ace are still special)
            if (topRank === Rank.SEVEN) {
                if (card.rank === Rank.TWO || card.rank === Rank.THREE || card.rank === Rank.ACE) {
                    return true;
                }
                return card.rank <= Rank.SEVEN;
            }

            // Special cards that can always be played (except on 7)
            if ([Rank.TEN, Rank.TWO, Rank.THREE, Rank.ACE].includes(card.rank)) {
                return true;
            }

            return card.rank >= topRank;
        }

        function playCards(playFaceDown = false) {
            if (game.selectedCards.length === 0) return;
            if (game.currentPlayerIdx !== myPlayerIndex) return;
            if (game.waitingForTarget) return;

            const player = game.players[myPlayerIndex];
            const cards = game.selectedCards.map(c => c.card);
            const isDefendingAce = game.aceAttackTarget === myPlayerIndex;
            const isBlind = player.isPlayingBlind();

            // If playing face down with lying enabled, ask what to declare
            let declaredRank = null;
            if (playFaceDown && game.allowLying) {
                const selection = prompt(`What rank do you want to declare for ${cards.length > 1 ? 'these cards' : 'this card'}?\n\nEnter number:\n2, 3, 4, 5, 6, 7, 8, 9, 10, 11=Jack, 12=Queen, 13=King, 14=Ace`);

                if (!selection) return;
                declaredRank = parseInt(selection);
                if (isNaN(declaredRank) || declaredRank < 2 || declaredRank > 14) {
                    alert('Invalid rank! Must be 2-14');
                    return;
                }
            }

            // Check if playing blind card that can't be played
            if (isBlind && cards.length > 0) {
                const blindCard = cards[0];
                if (!canPlayCard(blindCard, isDefendingAce)) {
                    // Remove the blind card from face-down
                    const sortedSelected = [...game.selectedCards].sort((a, b) => b.idx - a.idx);
                    for (let { location, idx } of sortedSelected) {
                        if (location === 'faceDown') {
                            player.faceDown.splice(idx, 1);
                        }
                    }

                    // Add blind card to hand and pick up pile
                    player.hand.push(blindCard);
                    player.hand.push(...game.pile);
                    showMessage(`${player.name} played ${blindCard.toString()} blind - can't play! Picks up pile with the card.`);
                    game.pile = [];
                    game.faceDownIndices = [];
                    game.declaredRanks = {};
                    game.aceAttackTarget = null;
                    game.mirroredRank = null;
                    game.selectedCards = [];
                    nextTurn();
                    return;
                }
            }

            // Validate non-blind cards (skip validation if playing face-down)
            if (!isBlind && !playFaceDown) {
                for (let card of cards) {
                    if (!canPlayCard(card, isDefendingAce)) {
                        showMessage(`Cannot play ${card.toString()}!`);
                        return;
                    }
                }
            }

            // Remove cards from player
            const sortedSelected = [...game.selectedCards].sort((a, b) => b.idx - a.idx);
            const startPileLength = game.pile.length;
            const numCards = cards.length;

            for (let { location, idx } of sortedSelected) {
                if (location === 'hand') {
                    game.pile.push(player.hand.splice(idx, 1)[0]);
                } else if (location === 'faceUp') {
                    game.pile.push(player.faceUp.splice(idx, 1)[0]);
                } else if (location === 'faceDown') {
                    game.pile.push(player.faceDown.splice(idx, 1)[0]);
                }
            }

            // Track which cards in pile are face-down and their declared ranks
            if (playFaceDown) {
                for (let i = 0; i < numCards; i++) {
                    const pileIdx = startPileLength + i;
                    game.faceDownIndices.push(pileIdx);
                    if (declaredRank) {
                        game.declaredRanks[pileIdx] = declaredRank;
                    }
                }
                // Immediately broadcast so other players know the declared rank
                broadcastGameState();
            }

            game.selectedCards = [];

            // Use declared rank if playing face-down, otherwise use actual rank
            const playedRank = (playFaceDown && declaredRank) ? declaredRank : cards[0].rank;

            // Track last played cards for lying mechanic
            if (game.allowLying) {
                // Clear previous lie opportunity when new cards are played
                game.canCallLie = false;
                game.lastPlayedCards = [...cards];

                // Store what was declared vs actual
                if (playFaceDown && declaredRank) {
                    game.declaredCards = cards.map(() => ({ rank: declaredRank }));
                    const rankName = RANK_NAMES[declaredRank];
                    showMessage(`${player.name} plays ${cards.length} ${rankName}${cards.length > 1 ? 's' : ''} face down`);
                } else {
                    game.declaredCards = [...cards];
                    showMessage(`${player.name} plays ${cards.map(c => c.toString()).join(', ')}`);
                }

                game.lastPlayerIdx = myPlayerIndex;
                // Enable lie calling after this play completes
                setTimeout(() => {
                    game.canCallLie = true;
                    broadcastGameState();
                    updateDisplay();
                }, 100);
            } else {
                showMessage(`${player.name} plays ${cards.map(c => c.toString()).join(', ')}`);
            }

            // Handle special cards
            if (playedRank === Rank.ACE && !isDefendingAce) {
                game.waitingForTarget = true;
                showMessage('Choose a player to attack!');
                showAttackPopup();
                broadcastGameState();
                updateDisplay();
                return;
            }

            if (playedRank === Rank.ACE && isDefendingAce) {
                game.waitingForTarget = true;
                showMessage(`${player.name} counters with Ace! Choose a player to attack!`);
                showAttackPopup();
                broadcastGameState();
                updateDisplay();
                return;
            }

            if (playedRank === Rank.TWO && isDefendingAce) {
                showMessage(`${player.name} blocks with 2!`);
                game.aceAttackTarget = null;
            }

            // Handle 3 (mirrors last non-3 card)
            if (playedRank === Rank.THREE && game.pile.length >= 2) {
                // Find the last non-3 card in the pile (check both actual and declared rank)
                let cardToMirror = null;
                let mirrorIndex = -1;
                for (let i = game.pile.length - 2; i >= 0; i--) {
                    const actualOrDeclaredRank = game.declaredRanks[i] || game.pile[i].rank;
                    if (actualOrDeclaredRank !== Rank.THREE) {
                        cardToMirror = game.pile[i];
                        mirrorIndex = i;
                        break;
                    }
                }

                if (cardToMirror) {
                    // Use declared rank if card was played face-down, otherwise use actual rank
                    const rankToMirror = game.declaredRanks[mirrorIndex] || cardToMirror.rank;
                    game.mirroredRank = rankToMirror;

                    const rankName = RANK_NAMES[rankToMirror];
                    showMessage(`${player.name} mirrors ${rankName} with 3!`);

                    // Apply the effect of the mirrored card (use declared rank if available)
                    if (rankToMirror === Rank.ACE) {
                        game.waitingForTarget = true;
                        showMessage(`${player.name} mirrors Ace! Choose a player to attack!`);
                        showAttackPopup();
                        broadcastGameState();
                        updateDisplay();
                        return;
                    } else if (rankToMirror === Rank.EIGHT) {
                        // Mirror 8's skip effect
                        game.skipsRemaining += numCards;
                        showMessage(`⏭️ 3 mirrors 8! ${numCards} more turn(s) skipped!`);
                    } else if (rankToMirror === Rank.TEN) {
                        // Mirror 10's burn effect
                        showMessage(`🔥 3 mirrors 10! ${player.name} burns the pile and plays again!`);
                        game.pile = [];
                        game.faceDownIndices = [];
                        game.declaredRanks = {};
                        game.aceAttackTarget = null;
                        game.mirroredRank = null;
                        drawCards(player);
                        broadcastGameState();
                        updateDisplay();
                        return;
                    }
                }
            } else if (playedRank !== Rank.THREE) {
                // Clear mirrored rank when a non-3 card is played
                game.mirroredRank = null;
            }

            if (playedRank === Rank.TEN) {
                game.aceAttackTarget = null;
            }

            if (checkForBurn()) {
                showMessage(`🔥 BURN! ${player.name} plays again!`);
                game.pile = [];
                game.faceDownIndices = [];
                game.declaredRanks = {};
                game.aceAttackTarget = null;
                game.mirroredRank = null;
                drawCards(player);
                broadcastGameState();
                updateDisplay();
                return;
            }

            if (playedRank === Rank.EIGHT) {
                game.skipsRemaining = numCards;
                showMessage(`⏭️ Next ${numCards} turn(s) skipped!`);
            }

            if (isDefendingAce) {
                game.aceAttackTarget = null;
            }

            if (!player.hasCards()) {
                showMessage(`🎉 ${player.name} wins!`);
                game.winnerName = player.name;
                showWinnerCelebration(player.name);
                broadcastGameState();
                updateDisplay();
                return;
            }

            drawCards(player);
            nextTurn();
        }

        function checkForBurn() {
            if (game.pile.length === 0) return false;

            if (game.pile[game.pile.length - 1].rank === Rank.TEN) {
                return true;
            }

            if (game.pile.length >= 4) {
                const lastFour = game.pile.slice(-4);
                if (lastFour.every(c => c.rank === lastFour[0].rank)) {
                    return true;
                }
            }

            return false;
        }

        function nextTurn() {
            // Clear lie calling opportunity when turn advances
            game.canCallLie = false;

            // Handle skip turns (from 8s)
            if (game.skipsRemaining > 0 && game.aceAttackTarget === null) {
                game.skipsRemaining--;
                game.currentPlayerIdx = (game.currentPlayerIdx + 1) % game.players.length;
                showMessage(`${game.players[game.currentPlayerIdx].name}'s turn skipped!`);

                if (game.skipsRemaining > 0) {
                    // More skips remaining, continue skipping
                    broadcastGameState();
                    updateDisplay();
                    setTimeout(nextTurn, 1500);
                    return;
                } else {
                    // Done skipping, move to next player
                    game.currentPlayerIdx = (game.currentPlayerIdx + 1) % game.players.length;
                }
            } else {
                // Normal turn advance
                game.currentPlayerIdx = (game.currentPlayerIdx + 1) % game.players.length;
            }

            game.players = game.players.filter(p => p.hasCards());
            if (game.players.length <= 1) {
                showMessage('Game Over!');
                broadcastGameState();
                updateDisplay();
                return;
            }

            game.currentPlayerIdx = game.currentPlayerIdx % game.players.length;

            showMessage(`${game.players[game.currentPlayerIdx].name}'s turn`);

            // Show popup if it's my turn
            if (game.currentPlayerIdx === myPlayerIndex) {
                showTurnPopup();
            }

            broadcastGameState();
            updateDisplay();
        }

        function pickupPile() {
            if (game.currentPlayerIdx !== myPlayerIndex) return;

            const player = game.players[myPlayerIndex];
            player.hand.push(...game.pile);
            showMessage(`${player.name} picks up ${game.pile.length} cards`);
            game.pile = [];
            game.faceDownIndices = [];
            game.declaredRanks = {};
            game.aceAttackTarget = null;
            game.mirroredRank = null;
            game.selectedCards = [];
            game.canCallLie = false;
            nextTurn();
        }

        function callLie() {
            if (!game.canCallLie) return;
            if (game.lastPlayerIdx === myPlayerIndex) return;
            if (game.lastPlayerIdx < 0) return;

            const liar = game.players[game.lastPlayerIdx];

            // Check if declared cards match actual played cards
            let wasLying = false;
            for (let i = 0; i < game.lastPlayedCards.length; i++) {
                const actualCard = game.lastPlayedCards[i];
                const declaredCard = game.declaredCards[i];
                if (actualCard.rank !== declaredCard.rank) {
                    wasLying = true;
                    break;
                }
            }

            if (wasLying) {
                showMessage(`🤥 ${liar.name} was lying! Actual: ${game.lastPlayedCards.map(c => c.toString()).join(', ')} vs Declared: rank ${game.declaredCards[0].rank}. ${liar.name} picks up the pile!`);
                liar.hand.push(...game.pile);
                game.pile = [];
                game.faceDownIndices = [];
                game.declaredRanks = {};
                game.mirroredRank = null;
                game.currentPlayerIdx = game.lastPlayerIdx;
            } else {
                showMessage(`❌ ${game.players[myPlayerIndex].name} called wrong! ${liar.name} was telling the truth! You pick up the pile!`);
                game.players[myPlayerIndex].hand.push(...game.pile);
                game.pile = [];
                game.faceDownIndices = [];
                game.declaredRanks = {};
                game.mirroredRank = null;
            }

            game.canCallLie = false;
            game.lastPlayedCards = [];
            game.declaredCards = [];
            game.lastPlayerIdx = -1;

            broadcastGameState();
            updateDisplay();
            nextTurn();
        }

        function showMessage(msg) {
            const messagesEl = document.getElementById('messages');
            messagesEl.innerHTML = `<span class="message-highlight">${msg}</span>`;
        }

        function showAttackPopup() {
            const popup = document.getElementById('attack-popup');
            popup.style.display = 'block';
        }

        function hideAttackPopup() {
            const popup = document.getElementById('attack-popup');
            popup.style.display = 'none';
        }

        function showTurnPopup() {
            const popup = document.getElementById('turn-popup');
            popup.style.display = 'block';

            // Play notification sound
            try {
                const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBTGH0fPTgjMGHm7A7+OZRQ0PVKzn77FZFwxNpuPzvmwjBzyP1PLUfi8GIXfH7+GURgsPU6vn77FZFwxNpuPzvmwjBzyP1PLUfi8GIXfH7+GURgsPU6vn77FZFwxNpuPzvmwjBzyP1PLUfi8GIXfH7+GURgsPU6vn77FZFwxNpuPzvmwjBzyP1PLUfi8GIXfH7+GURgsPU6vn77FZFwxNpuPzvmwjBzyP1PLUfi8GIXfH7+GURgsPU6vn77FZFwxNpuPzvmwjBzyP1PLUfi8GIXfH7+GURgsPU6vn77FZFwxNpuPzvmwjBzyP1PLUfi8GIXfH7+GURgsPU6vn77FZFwxNpuPzvmwjBzyP1PLUfi8GIXfH7+GURgsPU6vn77FZFwxNpuPzvmwjBzyP1PLUfi8GIXfH7+GURgsPU6vn77FZFwxNpuPzvmwjBzyP1PLUfi8GIXfH7+GURgsPU6vn77FZFwxNpuPzvmwjBzyP1PLUfi8GIXfH7+GURgsPU6vn77FZFwxNpuPzvmwjBzyP1PLUfi8GIXfH7+GURgsPU6vn77FZFwxNpuPzvmwjBzyP1PLUfi8GIXfH7+GURgsPU6vn77FZFwxNpuPzvmwjBzyP1PLUfi8GIXfH7+GURgsPU6vn77FZFw==');
                audio.volume = 0.5;
                audio.play().catch(e => console.log('Audio play failed:', e));
            } catch(e) {
                console.log('Audio creation failed:', e);
            }

            setTimeout(() => {
                popup.style.display = 'none';
            }, 2000);
        }

        function showWinnerCelebration(winnerName) {
            // Show overlay
            document.getElementById('winner-name').textContent = winnerName;
            document.getElementById('winner-overlay').style.display = 'flex';

            // Load and autoplay the YouTube video
            const videoFrame = document.getElementById('winner-video');
            videoFrame.src = 'https://www.youtube.com/embed/q_gQLY6_gFI?autoplay=1';

            // Create confetti
            const colors = ['#ffd700', '#ff6b6b', '#4ecdc4', '#45b7d1', '#f7b731', '#5f27cd'];
            for (let i = 0; i < 100; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.top = -10 + 'px';
                    confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDelay = Math.random() * 0.5 + 's';
                    confetti.style.animationDuration = Math.random() * 2 + 2 + 's';
                    document.body.appendChild(confetti);

                    setTimeout(() => confetti.remove(), 3000);
                }, i * 30);
            }
        }

        // Add click handlers for player targeting
        document.addEventListener('click', (e) => {
            const playerArea = e.target.closest('.player-area.targetable');
            if (playerArea && game.waitingForTarget && game.currentPlayerIdx === myPlayerIndex) {
                const playerIdx = parseInt(playerArea.id.split('-')[1]);
                targetPlayer(playerIdx);
            }
        });

        function targetPlayer(targetIdx) {
            if (!game.waitingForTarget) return;
            if (targetIdx === myPlayerIndex) return;
            if (game.currentPlayerIdx !== myPlayerIndex) return;

            hideAttackPopup();

            const attacker = game.players[myPlayerIndex];
            const target = game.players[targetIdx];

            game.aceAttackTarget = targetIdx;
            game.waitingForTarget = false;

            showMessage(`${attacker.name} attacks ${target.name}!`);

            drawCards(attacker);
            game.currentPlayerIdx = targetIdx;
            broadcastGameState();
            updateDisplay();
        }

        // Broadcast game state to all players
        function broadcastGameState() {
            const serialized = serializeGameState(game);
            socket.emit('gameStateUpdate', { roomCode, gameState: serialized });
        }

        // Serialize game state for transmission
        function serializeGameState(state) {
            return JSON.stringify(state);
        }

        // Deserialize game state
        function deserializeGameState(serialized) {
            const obj = JSON.parse(serialized);

            // Reconstruct Card objects
            obj.deck = obj.deck.map(c => new Card(c.rank, c.suit));
            obj.pile = obj.pile.map(c => new Card(c.rank, c.suit));
            obj.players = obj.players.map(p => {
                const player = new Player(p.name, p.id);
                player.hand = p.hand.map(c => new Card(c.rank, c.suit));
                player.faceUp = p.faceUp.map(c => new Card(c.rank, c.suit));
                player.faceDown = p.faceDown.map(c => new Card(c.rank, c.suit));
                return player;
            });

            return obj;
        }
    </script>
</body>
</html>
